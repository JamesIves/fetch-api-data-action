"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils_1 = require("tsutils");
const ts = __importStar(require("typescript"));
const _1 = require(".");
/**
 * Returns:
 * - null if the type is not an array or tuple,
 * - true if the type is a readonly array or readonly tuple,
 * - false if the type is a mutable array or mutable tuple.
 */
function isTypeReadonlyArrayOrTuple(checker, type) {
    function checkTypeArguments(arrayType) {
        const typeArguments = checker.getTypeArguments(arrayType);
        /* istanbul ignore if */ if (typeArguments.length === 0) {
            // this shouldn't happen in reality as:
            // - tuples require at least 1 type argument
            // - ReadonlyArray requires at least 1 type argument
            return true;
        }
        // validate the element types are also readonly
        if (typeArguments.some(typeArg => !isTypeReadonly(checker, typeArg))) {
            return false;
        }
        return true;
    }
    if (checker.isArrayType(type)) {
        const symbol = _1.nullThrows(type.getSymbol(), _1.NullThrowsReasons.MissingToken('symbol', 'array type'));
        const escapedName = symbol.getEscapedName();
        if (escapedName === 'Array' && escapedName !== 'ReadonlyArray') {
            return false;
        }
        return checkTypeArguments(type);
    }
    if (checker.isTupleType(type)) {
        if (!type.target.readonly) {
            return false;
        }
        return checkTypeArguments(type);
    }
    return null;
}
/**
 * Returns:
 * - null if the type is not an object,
 * - true if the type is an object with only readonly props,
 * - false if the type is an object with at least one mutable prop.
 */
function isTypeReadonlyObject(checker, type) {
    function checkIndexSignature(kind) {
        const indexInfo = checker.getIndexInfoOfType(type, kind);
        if (indexInfo) {
            return indexInfo.isReadonly ? true : false;
        }
        return null;
    }
    const properties = type.getProperties();
    if (properties.length) {
        // ensure the properties are marked as readonly
        for (const property of properties) {
            if (!tsutils_1.isPropertyReadonlyInType(type, property.getEscapedName(), checker)) {
                return false;
            }
        }
        // all properties were readonly
        // now ensure that all of the values are readonly also.
        // do this after checking property readonly-ness as a perf optimization,
        // as we might be able to bail out early due to a mutable property before
        // doing this deep, potentially expensive check.
        for (const property of properties) {
            const propertyType = _1.nullThrows(checker.getTypeOfPropertyOfType(type, property.getName()), _1.NullThrowsReasons.MissingToken(`property "${property.name}"`, 'type'));
            if (!isTypeReadonly(checker, propertyType)) {
                return false;
            }
        }
    }
    const isStringIndexSigReadonly = checkIndexSignature(ts.IndexKind.String);
    if (isStringIndexSigReadonly === false) {
        return isStringIndexSigReadonly;
    }
    const isNumberIndexSigReadonly = checkIndexSignature(ts.IndexKind.Number);
    if (isNumberIndexSigReadonly === false) {
        return isNumberIndexSigReadonly;
    }
    return true;
}
/**
 * Checks if the given type is readonly
 */
function isTypeReadonly(checker, type) {
    if (tsutils_1.isUnionType(type)) {
        // all types in the union must be readonly
        return tsutils_1.unionTypeParts(type).every(t => isTypeReadonly(checker, t));
    }
    // all non-object, non-intersection types are readonly.
    // this should only be primitive types
    if (!tsutils_1.isObjectType(type) && !tsutils_1.isUnionOrIntersectionType(type)) {
        return true;
    }
    // pure function types are readonly
    if (type.getCallSignatures().length > 0 &&
        type.getProperties().length === 0) {
        return true;
    }
    const isReadonlyArray = isTypeReadonlyArrayOrTuple(checker, type);
    if (isReadonlyArray !== null) {
        return isReadonlyArray;
    }
    const isReadonlyObject = isTypeReadonlyObject(checker, type);
    /* istanbul ignore else */ if (isReadonlyObject !== null) {
        return isReadonlyObject;
    }
    throw new Error('Unhandled type');
}
exports.isTypeReadonly = isTypeReadonly;
//# sourceMappingURL=isTypeReadonly.js.map