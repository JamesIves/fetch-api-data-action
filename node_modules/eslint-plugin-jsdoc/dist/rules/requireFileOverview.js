"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const defaultTags = {
  file: {
    initialCommentsOnly: true,
    mustExist: true,
    preventDuplicates: true
  }
};

const setDefaults = state => {
  // First iteration
  if (!state.globalTags) {
    state.globalTags = {};
    state.hasDuplicates = {};
    state.hasTag = {};
    state.hasNonCommentBeforeTag = {};
  }
};

var _default = (0, _iterateJsdoc.default)(({
  jsdocNode,
  state,
  utils,
  context
}) => {
  const _ref = context.options[0] || {},
        _ref$tags = _ref.tags,
        tags = _ref$tags === void 0 ? defaultTags : _ref$tags;

  setDefaults(state);

  for (var _i = 0, _Object$keys = Object.keys(tags); _i < _Object$keys.length; _i++) {
    const tagName = _Object$keys[_i];
    const targetTagName = utils.getPreferredTagName({
      tagName
    });
    const hasTag = targetTagName && utils.hasTag(targetTagName);
    state.hasTag[tagName] = hasTag || state.hasTag[tagName];
    const hasDuplicate = state.hasDuplicates[tagName];

    if (hasDuplicate === false) {
      // Was marked before, so if a tag now, is a dupe
      state.hasDuplicates[tagName] = hasTag;
    } else if (!hasDuplicate && hasTag) {
      // No dupes set before, but has first tag, so change state
      //   from `undefined` to `false` so can detect next time
      state.hasDuplicates[tagName] = false;
      state.hasNonCommentBeforeTag[tagName] = state.hasNonComment && state.hasNonComment < jsdocNode.start;
    }
  }
}, {
  exit({
    context,
    state,
    utils
  }) {
    setDefaults(state);

    const _ref2 = context.options[0] || {},
          _ref2$tags = _ref2.tags,
          tags = _ref2$tags === void 0 ? defaultTags : _ref2$tags;

    for (var _i2 = 0, _Object$entries = Object.entries(tags); _i2 < _Object$entries.length; _i2++) {
      const _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
            tagName = _Object$entries$_i[0],
            _Object$entries$_i$ = _Object$entries$_i[1],
            _Object$entries$_i$$m = _Object$entries$_i$.mustExist,
            mustExist = _Object$entries$_i$$m === void 0 ? false : _Object$entries$_i$$m,
            _Object$entries$_i$$p = _Object$entries$_i$.preventDuplicates,
            preventDuplicates = _Object$entries$_i$$p === void 0 ? false : _Object$entries$_i$$p,
            _Object$entries$_i$$i = _Object$entries$_i$.initialCommentsOnly,
            initialCommentsOnly = _Object$entries$_i$$i === void 0 ? false : _Object$entries$_i$$i;

      const obj = utils.getPreferredTagNameObject({
        tagName
      });

      if (obj && obj.blocked) {
        utils.reportSettings(`\`settings.jsdoc.tagNamePreference\` cannot block @${obj.tagName} ` + 'for the `require-file-overview` rule');
      } else {
        const targetTagName = obj && obj.replacement || obj;

        if (mustExist && !state.hasTag[tagName]) {
          utils.reportSettings(`Missing @${targetTagName}`);
        }

        if (preventDuplicates && state.hasDuplicates[tagName]) {
          utils.reportSettings(`Duplicate @${targetTagName}`);
        }

        if (initialCommentsOnly && state.hasNonCommentBeforeTag[tagName]) {
          utils.reportSettings(`@${targetTagName} should be at the beginning of the file`);
        }
      }
    }
  },

  iterateAllJsdocs: true,
  meta: {
    schema: [{
      additionalProperties: false,
      properties: {
        tags: {
          patternProperties: {
            '.*': {
              additionalProperties: false,
              properties: {
                initialCommentsOnly: {
                  type: 'boolean'
                },
                mustExist: {
                  type: 'boolean'
                },
                preventDuplicates: {
                  type: 'boolean'
                }
              },
              type: 'object'
            }
          },
          type: 'object'
        }
      },
      type: 'object'
    }],
    type: 'suggestion'
  },

  nonComment({
    state,
    node
  }) {
    if (!state.hasNonComment) {
      state.hasNonComment = node.start;
    }
  }

});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=requireFileOverview.js.map